// В регулярных выражениях появилась возможность ретроспективной проверки строк (?<=). Это позволяет искать в строках некие конструкции, перед которыми есть какие-то другие конструкции.
// Возможность опережающих проверок, использующая конструкцию ?=, имелась в регулярных выражениях, реализованных в JavaScript, и до стандарта ES2018. Такие проверки позволяют узнать, следует ли за неким фрагментом строки другой фрагмент.

const r = /Roger(?= Waters)/;
const res1 = r.test("Roger is my dog");
const res2 = r.test("Roger is my dog and Roger Waters is a famous musician");
console.log(res1); //false
console.log(res2); //true

// Конструкция ?! выполняет обратную операцию — совпадение будет найдено только в том случае, если за заданной строкой не идёт другая строка.

const r = /Roger(?! Waters)/g;
const res1 = r.test("Roger is my dog");
const res2 = r.test("Roger is my dog and Roger Waters is a famous musician");
console.log(res1); //true
console.log(res2); //false

// При ретроспективной проверке, как уже было сказано, используется конструкция ?<=.

const r = /(?<=Roger) Waters/;
const res1 = r.test("Pink Waters is my dog");
const res2 = r.test("Roger is my dog and Roger Waters is a famous musician");
console.log(res1); //false
console.log(res2); //true

// Операцию, обратную описанной, можно выполнить с помощью конструкции ?<!.

const r = /(?<!Roger) Waters/;
const res1 = r.test("Pink Waters is my dog");
const res2 = r.test("Roger is my dog and Roger Waters is a famous musician");
console.log(res1); //true
console.log(res2); //false

// Управляющие последовательности Unicode в регулярных выражениях. В регулярных выражениях можно использовать класс \d, соответствующий любой цифре, класс \s, соответствующий любому пробельному символу, класс \w, который соответствует любому буквенно-цифровому символу, и так далее. Возможность, о которой идёт речь, расширяет набор классов, которыми можно пользоваться в регулярных выражениях, позволяя работать с Unicode-последовательностями. Речь идёт о классе \p{} и об обратном ему классе \P{}.
// В Unicode каждый символ имеет набор свойств. Эти свойства указываются в фигурных скобках группы \p{}. Так, например, свойство Script определяет семейство языков, к которому принадлежит символ, свойство ASCII, логическое, принимает значение true для ASCII-символов, и так далее. Например, выясним, содержат ли некие строки исключительно ASCII-символы.

console.log(r.test("abc")); //true
console.log(r.test("ABC@")); //true
console.log(r.test("ABCЖ")); //false

// Свойство ASCII_Hex_Digit принимает значение true только для символов, которые можно использовать для записи шестнадцатеричных чисел.

const r = /^\p{ASCII_Hex_Digit}+$/u;

console.log(r.test("0123456789ABCDEF")); //true
console.log(r.test("H")); //false

// Существует и множество других подобных свойств, которые используются так же, как вышеописанные. Среди них — Uppercase, Lowercase, White_Space, Alphabetic, Emoji.
// Вот, например, как с помощью свойства Script определить, какой алфавит используется в строке. Здесь мы проверяем строку на использование греческого алфавита.

const r = /^\p{Script=Greek}+$/u;
console.log(r.test("ελληνικά")); //true
console.log(r.test("hey")); //false

// Именованные группы
// Захваченным группам символов в ES2018 можно давать имена. Вот как это выглядит.

const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const result = re.exec("2015-01-02");
console.log(result);
/*
[ '2015-01-02',
  '2015',
  '01',
  '02',
  index: 0,
  input: '2015-01-02',
  groups: { year: '2015', month: '01', day: '02' } ]
*/

// Без использования именованных групп те же данные были бы доступны лишь как элементы массива.

const re = /(\d{4})-(\d{2})-(\d{2})/;
const result = re.exec("2015-01-02");
console.log(result);
/*
[ '2015-01-02',
  '2015',
  '01',
  '02',
  index: 0,
  input: '2015-01-02',
  groups: undefined ]
*/

// Флаг регулярных выражений.
// Использование флага s приводит к тому, что символ . (точка) будет, кроме прочих, соответствовать и символу новой строки. Без использования этого флага точка соответствует любому символу за исключением символа новой строки.

console.log(/hi.welcome/.test("hi\nwelcome")); // false
console.log(/hi.welcome/s.test("hi\nwelcome")); // true

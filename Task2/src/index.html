<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./style.css">
    
</head>
<body>
    <header class="header" id="top">
        <div class="container-content">
            <a href="#top" hidden class="link_up">
                <i id="" class="fas fa-arrow-circle-up"></i>
            </a>
        <h2 class="header__title">
            JS начиная от ECMAScript 6
        </h2>   
        <div class="header-menu">
            <div class="header-menu__link">
                <a class="link_top" href="#arrows">Стрелочные функции</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#classes">Классы</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#defaultParam">Параметры по умалчиванию</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#destruction">Деструктуризация</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#forOf">for...of</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#forOf">for...of</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#generators">Итераторы, генераторы</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#object">Объекты</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#promise">Промисы</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#promiseAll">Promise all</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#proxy">Proxy</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#reflect">Reflect</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#map">Map</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#set">Set</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#spread">Spread, Rest</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#strMethods">String methods</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#literals">Шаблонные литералы</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#variables">Variables</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#arrMethods">Методы массивов</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#asyncAwait">Async await</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#forAwaitOf">for-await-of</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#tryCatch">try...catch</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#expImp">Експорт, Импорт</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#comma">Висящие запятые</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#bigInt">BigInt</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#regExp">Регулярные выражения</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#optChain">Опциональная цепочка</a>
            </div>
            <div class="header-menu__link">
                <a class="link_top"  href="#symbol">Symbol</a>
            </div>
        </div>
    </div>
</header>
<main>
    <div class="container-content">
        <div class="content">
            <div class="content__info">
                <div class="content__block" id="arrows" >
                    <h3 class="content__block__title">Стрелочные функции</h3>
                    <span class="content__block__text">Два фактора повлияли на появление стрелочных функции: более короткий синтаксис и лексика this.</span>
                    <img class="content__block__img"  src="./pictures/arrowFunction/img1.PNG" alt="picture">
                    <span class="content__block__text">У стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.
                    Если бы мы использовали обычную функцию, была бы ошибка.</span>
                    <img class="content__block__img"  src="./pictures/arrowFunction/img2.PNG" alt="picture">
                </div>                
                <div  class="content__block" id="#classes">
                    <h3 class="content__block__title">Классы</h3>
                    <span class="content__block__text">Добавлен более удобный синтаксис, удобное наследование. Доступен функционал геттеров и сеттеров</span>
                    <img class="content__block__img"  src="./pictures/classes/img1.PNG" alt="picture">
                    <span class="content__block__text">За счет того что метод который определен как статический можно к нему обращаться на прямую.</span>
                    <img class="content__block__img"  src="./pictures/classes/img2.PNG" alt="picture">
                </div>                
                <div class="content__block" id="defaultParam" >
                    <h3 class="content__block__title">Параметры по умолчанию</h3>
                    <span class="content__block__text">Параметры по умолчанию позволяют задавать формальным параметрам функции значения по умолчанию в случае, если функция
                    вызвана без аргументов, или если параметру явным образом передано значение undefined.</span>
                    <img class="content__block__img"  src="./pictures/defaultParams.PNG" alt="picture">
                </div>         
                <div class="content__block" id="destruction" >
                    <h3 class="content__block__title">Деструктуризация</h3>
                    <span class="content__block__text">Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив
                    или объект сразу нескольким переменным, разбив его на части.
                    </span>
                    <img class="content__block__img"  src="./pictures/destructuring/img1.PNG" alt="picture">
                    <span class="content__block__text">Деструктуризацию можно использовать и с объектами. Деструктуризацию можно использовать и с объектами.
                    </span>
                    <img class="content__block__img"  src="./pictures/destructuring/img2.PNG" alt="picture">
                </div>         
                <div class="content__block" id="forOf" >
                    <h3 class="content__block__title">for...of</h3>
                    <span class="content__block__text">Оператор for...of выполняет цикл обхода итерируемых объектов (включая Array, Map, Set, объект аргументов и подобных),
                    вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта. Емеет возможность break разрыва
                    </span>
                    <img class="content__block__img"  src="./pictures/for-of.png" alt="picture">
                </div>         
                <div class="content__block" id="generators" >
                    <h3 class="content__block__title">Итераторы, генераторы</h3>
                    <span class="content__block__text"> Объект является итератором, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая своё
                    текущее положение внутри этой последовательности. В JavaScript итератор - это объект, который предоставляет метод
                    next(), возвращающий следующий элемент последовательности. Этот метод возвращает объект с двумя свойствами: done и
                    value. Генератор - некоторая ф-я которая может последовательно выдавать результат своей работы. Они отличаются от обычных тем,
                    что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в
                    произвольный момент времени.
                    </span>
                    <img class="content__block__img"  src="./pictures/generators.PNG" alt="picture">
                </div>         
                <div class="content__block" id="object" >
                    <h3 class="content__block__title">Объекты</h3>
                    <span class="content__block__text">Нововведения</span>
                    <ul class="list">
                        <li class="list__element">можно создавать динамические ключи</li>
                        <li class="list__element">сокращенная запись если ключ и имя переменной совпадают</li>
                    </ul>
                    <img class="content__block__img"  src="./pictures/object/img1.PNG" alt="picture">
                    <span class="content__block__text">Методы</span>
                    <ul>
                        <li>Object.is() - определяет, являются ли два значения одинаковыми значениями.</li>
                        <li>Метод Object.assign() - используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в
                            целевой объект. После копирования возвращает целевой объект.</li>
                            <li>Object.entries() - возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value].</li>
                            <li>Object.values() - возвращает массив значений.</li>
                            <li>Object.getOwnPropertyDescriptor - возвращает все собственные дескрипторы свойств данного объекта. Дескриптор - это набор атрибутов свойства.</li>
                            <li>Object.fromEntries() - преобразует список пар ключ-значение в объект.</li>
                        </ul>
                        <img class="content__block__img" src="./pictures/object/img2.PNG" alt="picture">                
                </div>
                <div class="content__block" id='promise' >
                    <h3 class="content__block__title">Promise</h3>
                    <span class="content__block__text">Promise – предоставляют удобный способ организации асинхронного кода.
                    Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного
                    результата асинхронного метода возвращается своего рода обещание получить результат в некоторый момент в будущем. 
                    Появился метод finnaly.
                    </span>
                    <img class="content__block__img"  src="./pictures/promise/img1.PNG" alt="picture">
                </div> 
                <div class="content__block" id="promiseAll" >
                    <h3 class="content__block__title">Promise all</h3>
                    <span class="content__block__text"> Пример ниже. Имеется 3 промиса, в каждом из которых расположена функция setTimeout со случайной задержкой от 1 до 5 секунд.
                    Каждый промис своим результатом возвращает эту задержку.
                    С помощью Promise.all получили массив результатов, нашли его сумму, вывели на экран.
                    </span>
                    <img class="content__block__img"  src="./pictures/promise/promise-all.png" alt="picture">
                </div> 
                <div class="content__block" id="proxy" >
                    <h3 class="content__block__title">Proxy</h3>
                    <span class="content__block__text"> Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать)
                    разные действия с ним, например чтение/запись свойств и другие.
                    </span>
                    <img class="content__block__img"  src="./pictures/proxy.PNG" alt="picture">
                </div> 
                <div class="content__block" id="reflect" >
                    <h3 class="content__block__title">Reflect</h3>
                    <span class="content__block__text"> 
                        встроенный объект, который предоставляет методы для перехватывания JavaScript операций. Эти методы аналогичны методам
                        proxy handler`ов. Reflect - это не функциональный, а простой объект, он не является сконструированным.
                        В отличие от большинства глобальных объектов, Reflect - это не конструктор. Вы не можете использовать его с оператором
                        new или вызывать Reflect, как функцию. Все свойства и методы объекта Reflect являются статическими.
                    </span>
                    <img class="content__block__img"  src="./pictures/reflect.PNG" alt="picture">
                </div> 
                <div class="content__block" id="map" >
                    <h3 class="content__block__title">Map</h3>
                    <span class="content__block__text">MAP - это коллекция ключ/значение, как и Object. Но основное отличие в том, что
                        Map позволяет использовать ключи любого типа.
                        Имеет методы и свойства.
                    </span>
                    <img class="content__block__img" src="./pictures/map.PNG" alt="picture">
                </div>
                <div class="content__block" id="set" >
                    <h3 class="content__block__title">Set</h3>
                    <span class="content__block__text">Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только
                    один раз (уникальная коллекция). Имеет методы. Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за
                    счёт этого как раз и получается, что каждое значение появляется один раз. Например, мы ожидаем посетителей, и нам необходимо составить их список. Но повторные визиты не должны приводить к
                    дубликатам. Каждый посетитель должен появиться в списке только один раз.
                    </span>
                    <img class="content__block__img"  src="./pictures/set.PNG" alt="picture">
                </div> 
                <div class="content__block" id="spread" >
                    <h3 class="content__block__title">Rest, Spred</h3>
                    <span class="content__block__text">Остаточные параметры и оператор расширения.
                        Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
                        С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком
                        аргументов. Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.
                    </span>
                    <img class="content__block__img"  src="./pictures/rest.PNG" alt="picture">
                    <span>SPREAD оператор расширения. Он похож на остаточные параметры – тоже использует ..., но делает совершенно
                        противоположное. Он «расширяет» перебираемый объект в список аргументов..
                    </span>
                    <img class="content__block__img"  src="./pictures/spread.PNG" alt="picture">
                </div> 
                <div class="content__block" id="strMethods" >
                    <h3 class="content__block__title">String methods</h3>
                    <ul>
                        <li>str.repeat() - повторяет строки указанное количество раз.</li>
                        <li>str.codePointAt() возвращает не отрицательное целое число, которое является закодированным в UTF-16 значением кодовой точки.</li>
                        <li>str.padStart(), str.padEnd() - целью заполнения строки является добавление символов в строку, чтобы она достигла определенной длины</li>
                        <li>str.trimStart(), str.trimEnd() - могут быть использованы для обрезки пробелов в начале или в конце строки.</li>
                        <li>String.prototype.replaceAll() - возвращает новую строку со всеми совпадениями pattern , который меняется на replacement. pattern может быть строкой или
                        регулярным выражением, и replacement может быть строкой или функция возвращающая каждое совпадение.</li>
                    </ul>
                    <img class="content__block__img"  src="./pictures/stringMethods.PNG" alt="picture">
                </div> 
                <div class="content__block" id="literals" >
                    <h3 class="content__block__title">Шаблонные литералы</h3>
                    <span class="content__block__text">Шаблонными литералами называются строковые литералы, допускающие использование выражений внутри. С ними вы можете
                    использовать многострочные литералы и строковую интерполяцию.</span>
                    <img class="content__block__img"  src="./pictures/stringTemplate.PNG" alt="picture">
                </div> 
                <div class="content__block" id="variables" >
                    <h3 class="content__block__title">Let, const, var</h3>
                    <span class="content__block__text">Директива let позволяет объявить локальную переменную с областью видимости, ограниченной текущим блоком кода . В отличие
                    от ключевого слова var, которое объявляет переменную глобально или локально во всей функции, независимо от области
                    блока. Значение констант не может быть изменено новым присваиванием, а также не может быть переопределено. Константы (const)
                    подчиняются области видимости уровня блока так же, как переменные, объявленные с использованием ключевого слова let.</span>
                    <img class="content__block__img"  src="./pictures/variable.PNG" alt="picture">
                </div> 
                <div class="content__block" id="arrMethods" >
                    <h3 class="content__block__title">Методы массивов</h3>
                    <ul>
                        <li>array.includes() - вводит более читаемый синтаксис для проверки, содержит ли массив элемент, возвращая в зависимости от этого true или
                            false</li>
                            <li>Array.flat() - возвращает новый массив, в котором все подмассивы были рекурсивно “подняты” на указанный уровень глубины. Вызов
                            Array.flat() без каких-либо аргументов сглаживает только первый уровень глубины. Можно указать необязательный аргумент
                            глубины или вызвать функцию последовательно.</li>
                            <li>Array.flatMap() - идентичен методу map ES6, но в то же время сглаживает первый уровень глубины массива. Метод flatMap() сначала перебирает
                            каждый элемент с помощью функции map(), а затем выравнивает результат через flat() в новый массив.</li>
                        </ul>
                        <img class="content__block__img"  src="./pictures/arrayMethods/arrayMethods.PNG" alt="picture">
                </div> 
                <div class="content__block" id="asyncAwait" >
                    <h3 class="content__block__title">Async await</h3>
                    <span class="content__block__text">Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для
                    понимания и использования.</span>
                    <img class="content__block__img"  src="./pictures/asyncAwait.PNG" alt="picture">
                </div>
                <div class="content__block" id="forAwaitOf" >
                    <h3 class="content__block__title">For-await-of</h3>
                    <span class="content__block__text">Позволяет нам вызывать асинхронные функции, которые возвращают промис в цикле.</span>
                    <img class="content__block__img"  src="./pictures/for-await-of.PNG" alt="picture">
                </div>
                <div class="content__block" id="tryCatch" >
                    <h3 class="content__block__title">Try...catch</h3>
                    <span class="content__block__text">Конструкция try...catch пытается выполнить инструкции в блоке try, и, в случае ошибки, выполняет блок catch. C ES2019, необязательная привязка catch позволяет разработчикам использовать try/catch без параметра error внутри блока catch</span>
                    <img class="content__block__img"  src="./pictures/tryCatch.PNG" alt="picture">
                </div>
                <div class="content__block" id="expImp" >
                    <h3 class="content__block__title">Экспорт и импорт</h3>
                    <span class="content__block__text">Директивы экспорт и импорт имеют несколько вариантов вызова.</span>
                    <img class="content__block__img"  src="./pictures/export.PNG" alt="picture">
                    <span class="content__block__text">фигурные скобки необходимы в случае именованных экспортов, для export default они не нужны.</span>
                    <img class="content__block__img"  src="./pictures/import.PNG" alt="picture">
                </div>
                <div class="content__block" id="comma" >
                    <h3 class="content__block__title">Висящие запятые</h3>
                    <span class="content__block__text">Висящие запятые (Trailing commas) — могут быть полезны при добавлении новых элементов, параметров или свойств в код
                    JavaScript. Если вы хотите добавить новое свойство, вы просто добавляете новую строчку без изменения предыдущей, если в
                    ней уже использована висящая запятая. Это делает различия в контроле версий чище и изменение кода может быть менее
                    хлопотным.</span>
                    <img class="content__block__img"  src="./pictures/trailingCommas.PNG" alt="picture">
                </div>
                <div class="content__block" id="bigInt" >
                    <h3 class="content__block__title">BigInt</h3>
                    <span class="content__block__text">BigInt это встроенный объект, который предоставляет способ представлять целые числа больше 2 <sup>53</sup> - 1, наибольшего числа,
                    которое JavaScript может надёжно представить с Number примитивом. Это максимальное значение можно получить, обратившись
                    к Number.MAX_SAFE_INTEGER.</span>
                    <img class="content__block__img"  src="./pictures/bigInt.PNG" alt="picture">
                </div>  
                <div class="content__block" id="regExp" >
                    <h3 class="content__block__title">Регулярные выражения</h3>
                    <span class="content__block__text">В регулярных выражениях появилась возможность ретроспективной проверки строк (?<=). Это позволяет искать в строках некие
                        конструкции, перед которыми есть какие-то другие конструкции. Возможность опережающих проверок, использующая
                        конструкцию ?=, имелась в регулярных выражениях, реализованных в JavaScript, и до стандарта ES2018. Такие проверки
                        позволяют узнать, следует ли за неким фрагментом строки другой фрагмент. </span>
                    <img class="content__block__img"  src="./pictures/regExp/img1.PNG" alt="picture">
                    <span class="content__block__text">Управляющие последовательности Unicode в регулярных выражениях. В регулярных выражениях можно использовать класс \d,
                    соответствующий любой цифре, класс \s, соответствующий любому пробельному символу, класс \w, который соответствует
                    любому буквенно-цифровому символу, и так далее. Возможность, о которой идёт речь, расширяет набор классов, которыми
                    можно пользоваться в регулярных выражениях, позволяя работать с Unicode-последовательностями. Речь идёт о классе \p{} и
                    об обратном ему классе \P{}. В Unicode каждый символ имеет набор свойств. Эти свойства указываются в фигурных скобках группы \p{}. Так, например,
                    свойство Script определяет семейство языков, к которому принадлежит символ, свойство ASCII, логическое, принимает
                    значение true для ASCII-символов, и так далее. Например, выясним, содержат ли некие строки исключительно ASCII-символы.</span>
                    <img class="content__block__img"  src="./pictures/regExp/img2.PNG" alt="picture">
                    <span class="content__block__text">Именованные группы. Захваченным группам символов в ES2018 можно давать имена. Вот как это выглядит.</span>
                    <img class="content__block__img"  src="./pictures/regExp/img3.PNG" alt="picture">
                    <span class="content__block__text">Флаг регулярных выражений.
                    Использование флага s приводит к тому, что символ . (точка) будет, кроме прочих, соответствовать и символу новой
                    строки. Без использования этого флага точка соответствует любому символу за исключением символа новой строки.</span>
                    <img class="content__block__img"  src="./pictures/regExp/img4.PNG" alt="picture">
                </div>  
                <div class="content__block" id="optChain" >
                    <h3 class="content__block__title">Опциональная цепочка</h3>
                    <span class="content__block__text">Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из
                    промежуточных свойств не существует.</span>
                    <img class="content__block__img" src="./pictures/optionalChaining.PNG" alt="picture">
                </div>
                <div class="content__block" id="symbol" >
                    <h3 class="content__block__title">Symbol</h3>
                    <span class="content__block__text">Свойство description только для чтения - это строка, возвращающая необязательное описание объектов Symbol.</span>
                    <img class="content__block__img" src="./pictures/symbol.PNG" alt="picture">
                </div>
        </div>
    </div>
</main>
    <script src='./app.js'></script>
    <script src="https://kit.fontawesome.com/808597c4dd.js" crossorigin="anonymous"></script>
</body>
</html>